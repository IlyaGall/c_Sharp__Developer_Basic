# ДЗ
## [01 Разработка интерактивного меню для Телеграмм бота ](https://github.com/IlyaGall/C-/blob/main/%D0%94%D0%97/01%20homeWork/homeWork01Operatots/Program.cs)
* Приветствие: При запуске программы отображается сообщение приветствия со списком доступных команд: /start, /help, /info, /exit.
* Обработка команды /start: Если пользователь вводит команду /start, программа просит его ввести своё имя. Сохраните введенное имя в переменную. Программа должна обращаться к пользователю по имени в каждом следующем ответе.
* Обработка команды /help: Отображает краткую справочную информацию о том, как пользоваться программой.
* Обработка команды /info: Предоставляет информацию о версии программы и дате её создания.
* Доступ к команде /echo: После ввода имени становится доступной команда /echo. При вводе этой команды с аргументом (например, /echo Hello), программа возвращает введенный текст (в данном примере "Hello").
* Основной цикл программы: Программа продолжает ожидать ввод команды от пользователя, пока не будет введена команда /exit.

## [02 Сравнение коллекций](https://github.com/IlyaGall/C-/tree/main/%D0%94%D0%97/02%20HomeWork)


* Цель:
Сделать сравнение по скорости работы List, ArrayList и LinkedList.


* Описание/Пошаговая инструкция выполнения домашнего задания:
    * Создать коллекции List, ArrayList и LinkedList.
    * С помощью цикла for добавить в каждую 1 000 000 случайных значений с помощью класса Random.
    * С помощью Stopwatch.Start() и Stopwatch.Stop() замерить длительность заполнения каждой коллекции и вывести значения на экран.
    * Найти 496753-ий элемент, замерить длительность этого поиска и вывести на экран.
    * Вывести на экран каждый элемент коллекции, который без остатка делится на 777. Вывести длительность этой операции для каждой коллекции.
    * Укажите сколько времени вам понадобилось, чтобы выполнить это задание.

## [Исключения и их обработка](https://github.com/IlyaGall/C-/tree/main/%D0%94%D0%97/03%20HomeWork)

1 Решение квадратного уравнения с обработкой
ошибок
Цель: Цель домашнего задания - закрепить знания
о механизме работы с исключениями, полученным
в ходе вебинара. Студенты научатся писать код,
обрабатывающий исключения познакомятся с
различными примерами встроенных исключений.
Нужно написать программу, решающую квадратное
уравнение формата
a * x^2 + b * x + c = 0
Пользователю нужно ввести целые значения a, b, c
и на основе введенных значений рассчитать корни/
корень уравнения x
Шаги:
1. Вывести уравнение 
a * x^2 + b * x + c = 0
2. Вывести текст
Введите значение a: 
И считать значение a
3. Вывести текст
Введите значение b: 
И считать значение b
4. Вывести текст
Введите значение c: 
И считать значение c
5. Если какое-либо значение не является целым
число 
выбрасывается исключение, которое
обрабатывается функцией FormatData
(Приложение1)
с Severity = Error с выводом параметров, которые
не прошли парсинг 
[пример работы программы]
(https://pasteboard.co/KhJmoZC.png)
и возвращаемся к п.2
6. После этого нужно по формуле [решения
квадратных уравнений]
(https://www.berdov.com/docs/equation/quadratic_equ
ations/)
рассчитать все возможные значения x
6.1. Если вещественных решений - два,
вывести ответ в виде
x1 = ответ_1, x2 = ответ_2
6.2. Если решение - одно
вывести ответ в виде
x = ответ
6.3 Если вещественных решений нет - выбросить
Exception с текстом "Вещественных значений не
найдено",
и обработать функцией FormatData c Severity =
Warning (желтый фон)
Требования к коду
- Исключения ввода данных и исключения
ненахождения корней уравнения обрабатываются
разными catch
- Для исключения ненахождения ответов
уравнения нужно использовать собственный класс
- 
# доп. задание
Нужно вынести код получения данных (ф1) и код
расчета (ф2) в отдельные функции, 
но обработчики исключений, указанные в задании,
оставить в main.
В случае появления ошибки в функции расчета
(ф2) корней уравнения,
исключение обрабатывается сначала в функции
расчета,
потом в main как общее исключение и текст ошибки
выводится при помощи formData c Severity = Error
# задание со звездочкой
Вывести исходного уравнение и значения
переменных a, b, c, каждое с новой строки 
также вывести указатель '>' напротив строки с a
```
a * x^2 + b * x + c = 0
> a:
b:
c:
```
при помощи клавиш стрелок вверх и вниз сделать
навигацию между строками параметров a, b, c
при навигации символ '>' смещается вверх или
вниз 
при нажатии клавиш чисел вводятся значения для
выбранного параметра,
а буква параметра заменяется в уравнении на
введенное число
пример
```
a * x^2 + b * x + c = 0
> a:
b:
c:
24 * x^2 + b * x + c = 0
> a: 24
b:
c:
24 * x^2 + b * x + c = 0
a: 24
> b:
c:
24 * x^2 - 10 * x + c = 0
a: 24
> b: -10
c:
```
По нажатию enter переходим к шагам 5-6
Все исключения выводим в самом конце (под
строкой "C:"
Приложение1
Функция FormatData(string message, Severity
severity, IDictionary data)
где Severity - перечисление (enum)
enum Severity{
Warning,
Error
}
Функция FormatData выводит данные в следующем
виде
```
----------------------------------
message 
--------------------------------
параметр1 = значение1
параметр2 = значение2
```
где message - сообщение 
Разделительная линия имеет длину 50 символов
параметр1, параметр2 - значения из Data
Если Severity = Error, выводится в консоли белый
текст на красном фоне
Если Severity = Warning, выводится в консоли
черный текст на желтом фоне


# [04 задание](https://github.com/IlyaGall/C-/tree/main/%D0%94%D0%97/04%20HomeWork)
* писание/Пошаговая инструкция выполнения домашнего задания:

Стэк - тип данных, представляющий собой коллекцию элементов, организованную по принципу LIFO - Last In - First Out.
Данные в эту коллекцию могут добавляться только "сверху", и извлекать тоже сверху. Если мы добавили элемент1, а потом элемент2, то доступ к Элементу1 мы получим только после того как извлечем Элемент2.
В качестве примера стека может послужить стопка тарелок: мы кладем сверху тарелки, но если мы хотим взять тарелку из середины - надо для начала снять верхние.

* Основное задание
Нужно создать класс Stack у которого будут следующие свойства

В нем будем хранить строки
В качестве хранилища используйте список List
Конструктор стека может принимать неограниченное количество входных параметров типа string, которые по порядку добавляются в стек
Метод Add(string) - добавить элемент в стек
Метод Pop() - извлекает верхний элемент и удаляет его из стека. При попытке вызова метода Pop у пустого стека - выбрасывать исключение с сообщением "Стек пустой"
Свойство Size - количество элементов из Стека
Свойство Top - значение верхнего элемента из стека. Если стек пустой - возвращать null

**
Хорошая работа, стека работает согласно ТЗ. Рекомендации на будущее:
* 1.Классы принято выносить в отдельные файлы и называть как классы.
* 2 Стоит следить за codestyle и удалять лишние переносы строк
* 3 Top и Size лучше сделать через свойства. public int Size => myStack.Count;
* 4 List<string> myStack; - лучше сделать private readonly
* 5 Merge - лучше реализовать через Pop
* 6 ElementAt - лишний метод
**

# [05 задание](https://github.com/IlyaGall/C-/tree/main/%D0%94%D0%97/05%20HomeWork)
Описание/Пошаговая инструкция выполнения домашнего задания:
* Создать интерфейс ```IRobot``` с публичным методами ```string GetInfo()``` и ``List GetComponents()``, а также ```string GetRobotType()``` с дефолтной реализацией, возвращающей значение ```"I am a simple robot."```.
*  Создать интерфейс ``IChargeable`` с методами ```void Charge()``` и ```string GetInfo()```.
*  Создать интерфейс ```IFlyingRobot``` как наследник ```IRobot``` с дефолтной реализацией ```GetRobotType()```, возвращающей строку ```"I am a flying robot."```.
*  Создать класс Quadcopter, реализующий ```IFlyingRobot``` и ```IChargeable```. В нём создать список компонентов``` List _components = new List {"rotor1","rotor2","rotor3","rotor4"}``` и возвращать его из метода ```GetComponents()```.
*  Реализовать метод ```Charge()``` должен писать в консоль ```"Charging..."``` и через 3 секунды ```"Charged!"```. Ожидание в 3 секунды реализовать через``` Thread.Sleep(3000)```.
*   Реализовать все методы интерфейсов в классе. До этого пункта достаточно было " ```throw new NotImplementedException();"```
*   В чат напишите также время, которое вам потребовалось для реализации домашнего задания.


# [06 задание ] (https://github.com/IlyaGall/C-/tree/main/%D0%94%D0%97/06%20HomeWork)
## Программа 1.
Создать четыре объекта анонимного типа для описания планет Солнечной системы со свойствами "Название", "Порядковый номер от Солнца", "Длина экватора", "Предыдущая планета" (ссылка на объект - предыдущую планету):

Венера
Земля
Марс
Венера (снова) Данные по планетам взять из открытых источников. Вывести в консоль информацию обо всех созданных "планетах". Рядом с информацией по каждой планете вывести эквивалентна ли она Венере.
## Программа 2.
Написать обычный класс "Планета" со свойствами "Название", "Порядковый номер от Солнца", "Длина экватора", "Предыдущая планета" (ссылка на предыдущую Планету). Написать класс "Каталог планет". В нем должен быть список планет - при создании экземпляра класса сразу заполнять его тремя планетами: Венера, Земля, Марс. Добавить в класс "Каталог планет" метод "получить планету", который на вход принимает название планеты, а на выходе дает три поля: первые два поля порядковый номер планеты от Солнца и длину ее экватора, когда планета найдена, а последнее поле - для ошибки. В случае, если планету по названию найти не удалось, то этот метод должен возвращать строку "Не удалось найти планету" (именно строку, не Exception). На каждый третий вызов метод "получить планету" должен возвращать строку "Вы спрашиваете слишком часто". В main-методе Вашей программы создать экземпляр "Каталога планет". У этого каталога вызвать метод "получить планету", передав туда последовательно названия Земля, Лимония, Марс. Для найденных планет в консоль выводить их название, порядковый номер и длину экватора. А для ненайденных выводить строку ошибки, которую вернул метод "получить планету".

## Программа 3.
Скопировать решение из программы 2, но переделать метод "получить планету" так, чтобы он на вход принимал еще один параметр, описывающий способ защиты от слишком частых вызовов - делегат PlanetValidator (можно вместо него использовать Func), который на вход принимает название планеты, а на выходе дает строку с ошибкой. Метод "получить планету" теперь не должен проверять сколько вызовов делалось ранее. Вместо этого он должен просто вызвать PlanetValidator и передать в него название планеты, поиск которой производится. И если PlanetValidator вернул ошибку - передать ее на выход из метода третьим полем. Из main-метода при вызове "получить планету" в качестве нового параметра передавать лямбду, которая делает всё ту же проверку, которая была и ранее - на каждый третий вызов она возвращает строку "Вы спрашиваете слишком часто" (в остальных случаях возвращает null). Результат исполнения программы должен получиться идентичный программе 2.

## Программа 3_1 (*) лежет в том же решение, что и программа 3.
(*) Дописать main-метод так, чтобы еще раз проверять планеты "Земля", "Лимония" и "Марс", но передавать другую лямбду так, чтобы она для названия "Лимония" возвращала ошибку "Это запретная планета", а для остальных названий - null. Убедиться, что в этой серии проверок ошибка появляется только для Лимонии. Таким образом, вы делегировали логику проверки допустимости найденной планеты от метода "получить планету" к вызывающему этот метод коду. В чат напишите также время, которое вам потребовалось для реализации домашнего задания.

# [07 задание ] (https://github.com/IlyaGall/C-/tree/main/%D0%94%D0%97/07%20HomeWork)

* Реализовать метод нахождения n-го члена последовательности Фибоначчи по формуле F(n) = F(n-1) + F(n-2) с помощью рекурсивных вызовов.
* Реализовать метод нахождения n-го члена последовательности Фибоначчи по формуле F(n) = F(n-1) + F(n-2) с помощью цикла.
* Добавить подсчёт времени на выполнение рекурсивного и итеративного методов с помощью Stopwatch и написать сколько времени для значений 5, 10 и 20.